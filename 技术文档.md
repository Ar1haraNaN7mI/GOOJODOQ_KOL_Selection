# TikTok达人匹配系统 - 技术文档

## 🔧 技术架构

### 系统组件
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端界面      │    │   Flask API     │    │   数据引擎      │
│   index.html    │◄──►│   app.py        │◄──►│real_data_matcher│
│   styles.css    │    │   (523行)       │    │   (457行)       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
                       ┌─────────────────┐
                       │   数据源        │
                       │ 152,404达人     │
                       │ 8,619产品       │
                       └─────────────────┘
```

### 技术栈
- **后端**: Python 3.8+ + Flask + pandas + scikit-learn
- **前端**: HTML5 + CSS3 + JavaScript (原生)
- **数据**: Excel + CSV 处理
- **AI**: TF-IDF文本向量化 + 余弦相似度

## 📊 数据结构

### 达人数据字段 (23个字段)
```python
creator_fields = [
    'Creator_username',           # 达人用户名
    'Affiliate_GMV',             # 联盟GMV (核心指标)
    'Affiliate_followers',       # 粉丝数
    'Est_commission',            # 预估佣金
    'Avg_order_value',          # 平均订单价值
    'CTR',                      # 点击转化率
    # ... 其他18个字段
]
```

### 产品数据字段 (53个字段)
```python
product_fields = [
    'Creator_username',          # 关联达人
    '商品类别',                  # 权重0.6
    '商品介绍',                  # 权重0.8
    '功能特性',                  # 权重1.0 (最重要)
    'Affiliate_GMV',            # 历史GMV数据
    # ... 其他48个字段
]
```

## 🧠 核心算法

### 1. 产品匹配算法
```python
def weighted_product_matching(query, products):
    # 多字段TF-IDF向量化
    feature_vectors = tfidf_vectorize(products['功能特性'])  # 权重1.0
    intro_vectors = tfidf_vectorize(products['商品介绍'])    # 权重0.8
    category_vectors = tfidf_vectorize(products['商品类别'])  # 权重0.6
    
    # 计算相似度
    feature_sim = cosine_similarity(query_vector, feature_vectors)
    intro_sim = cosine_similarity(query_vector, intro_vectors)
    category_sim = cosine_similarity(query_vector, category_vectors)
    
    # 加权平均
    weighted_score = (
        feature_sim * 1.0 + 
        intro_sim * 0.8 + 
        category_sim * 0.6
    ) / 2.4
    
    return weighted_score
```

### 2. 激进差异化定价
```python
def calculate_aggressive_pricing(followers):
    if followers <= 10000:
        base_cost = followers * 0.025
    elif followers <= 50000:
        base_cost = 250 + (followers - 10000) * 0.055
    elif followers <= 100000:
        base_cost = 2450 + (followers - 50000) * 0.075
    elif followers <= 300000:
        base_cost = 6200 + (followers - 100000) * 0.095
    elif followers <= 1000000:
        base_cost = 25200 + (followers - 300000) * 0.06
    else:
        base_cost = 67200 + (followers - 1000000) * 0.03
    
    # 多因素调整
    multiplier = (
        gmv_factor * 0.40 +
        commission_factor * 0.30 +
        engagement_factor * 0.20 +
        aov_factor * 0.10
    )
    
    # 双上限控制
    estimated_cost = base_cost * multiplier
    estimated_cost = min(estimated_cost, followers * 0.15)  # 15%上限
    estimated_cost = min(estimated_cost, (followers/1000) * 200)  # 200元/千粉上限
    
    return estimated_cost
```

### 3. 动态权重排序
```python
def dynamic_weighted_ranking(creators, has_product_match):
    if has_product_match:
        # 产品匹配优先模式
        score = (
            product_match_score * 0.50 +
            gmv_normalized * 0.25 +
            commission_normalized * 0.15 +
            engagement_normalized * 0.10
        )
    else:
        # 纯性能模式
        score = (
            gmv_normalized * 0.40 +
            commission_normalized * 0.30 +
            engagement_normalized * 0.20 +
            aov_normalized * 0.10
        )
    
    return sorted(creators, key=lambda x: x['score'], reverse=True)
```

## 🌐 API接口规范

### 推荐接口
```http
POST /api/recommend
Content-Type: application/json

Request:
{
    "product_description": "string",      // 必填：产品描述
    "budget": number,                    // 可选：预算上限
    "top_k": number,                     // 可选：返回数量(默认10)
    "min_gmv": number,                   // 可选：最低GMV要求
    "min_followers": number,             // 可选：最低粉丝数
    "max_followers": number              // 可选：最高粉丝数
}

Response:
{
    "success": boolean,
    "recommendations": [
        {
            "rank": number,
            "creator_username": "string",
            "performance": {
                "gmv": number,
                "estimated_gmv_7pct": number,
                "commission": number
            },
            "cost": {
                "estimated_cost": number,
                "cost_per_thousand_followers": number
            },
            "product_matching": {
                "match_score": number,      // 0-1之间
                "combined_score": number    // 综合得分
            }
        }
    ],
    "statistics": {
        "total_cost": number,
        "budget_utilization": "string",
        "cost_calculation_method": "string"
    },
    "processing_time": number
}
```

### 错误响应
```json
{
    "success": false,
    "error": "错误描述",
    "error_code": "ERROR_TYPE"
}
```

## 📈 性能优化

### 数据处理优化
- **内存管理**: 使用pandas分块读取大文件
- **向量缓存**: TF-IDF向量一次计算，内存缓存
- **数值转换**: 非数值字符预处理，缺失值填充

### 查询优化
- **预过滤**: 根据条件提前筛选数据集
- **并行计算**: 相似度计算使用向量化操作
- **结果缓存**: 动态缓存热门查询结果

### 系统监控
```python
# 性能指标
startup_time = 45-60秒          # 数据加载时间
query_response = 0.3-0.6秒      # 查询响应时间
memory_usage = ~800MB           # 内存使用量
concurrent_users = 10-50        # 并发支持
```

## 🔐 配置参数

### 系统配置
```python
# app.py 配置
FLASK_HOST = '0.0.0.0'
FLASK_PORT = 5000
DEBUG_MODE = False

# 数据源配置
CREATOR_DATA_PATH = 'Match_ProductCreator-main/Creator_List_Viet.xlsx'
PRODUCT_DATA_PATH = 'Match_ProductCreator-main/Product_Creator_OCRAll_Viet0530.xlsx'

# 算法参数
PRODUCT_WEIGHTS = {
    '功能特性': 1.0,
    '商品介绍': 0.8,
    '商品类别': 0.6
}

# 价格算法参数
PRICING_TIERS = [
    (10000, 0.025),
    (50000, 250, 0.055),
    (100000, 2450, 0.075),
    (300000, 6200, 0.095),
    (1000000, 25200, 0.06),
    (float('inf'), 67200, 0.03)
]

# 上限控制
MAX_COST_PER_THOUSAND = 200     # 每千粉上限
MAX_COST_PERCENTAGE = 0.15      # 总价上限比例
```

## 🛠️ 部署指南

### 环境要求
```bash
# Python版本
python >= 3.8

# 系统要求
内存: >= 2GB (推荐4GB+)
存储: >= 1GB
操作系统: Windows 10/11, macOS, Linux
```

### 依赖安装
```bash
pip install flask==2.3.3
pip install flask-cors==4.0.0
pip install pandas==2.0.3
pip install numpy==1.24.3
pip install scikit-learn==1.3.0
pip install openpyxl==3.1.2
```

### 启动命令
```bash
# 开发环境
python app.py

# 生产环境 (推荐使用gunicorn)
gunicorn -w 4 -b 0.0.0.0:5000 app:app
```

## 📝 开发规范

### 代码结构
```
app.py                      # Flask主应用
├── 初始化系统               # 数据加载
├── 费用计算算法             # calculate_estimated_cost()
├── 产品条件解析             # parse_product_to_filters()
├── 路由定义                # API endpoints
└── 错误处理                # exception handlers

real_data_matcher.py        # 数据匹配引擎
├── 数据加载类               # RealDataMatcher
├── 产品向量化               # build_product_vectors()
├── 筛选算法                # filter_creators()
└── 排序算法                # dynamic ranking
```

### 日志规范
```python
import logging

# 日志级别
logging.INFO    # 系统运行信息
logging.DEBUG   # 详细调试信息  
logging.WARNING # 警告信息
logging.ERROR   # 错误信息

# 日志格式
'%(asctime)s - %(levelname)s - %(message)s'
```

### 错误处理
```python
try:
    # 业务逻辑
    pass
except Exception as e:
    logger.error(f"错误描述: {e}")
    return {"success": False, "error": str(e)}
```

## 🔍 调试指南

### 常用调试命令
```bash
# 检查系统状态
curl http://localhost:5000/api/health

# 查看系统统计
curl http://localhost:5000/api/stats

# 测试推荐API
curl -X POST http://localhost:5000/api/recommend \
  -H "Content-Type: application/json" \
  -d '{"product_description":"test product","budget":10000}'
```

### 性能监控
```python
# 查询时间监控
import time
start_time = time.time()
# ... 业务逻辑 ...
processing_time = time.time() - start_time

# 内存使用监控
import psutil
memory_usage = psutil.Process().memory_info().rss / 1024 / 1024  # MB
```

---

## 📞 技术支持

**开发者**: 北京夜羊科技有限公司 
**技术栈**: Python + Flask + scikit-learn  
**版本**: v2.0.0  
**最后更新**: 2025-05-31

**问题反馈**: 通过系统日志定位问题，检查数据文件完整性，确认依赖版本兼容性 